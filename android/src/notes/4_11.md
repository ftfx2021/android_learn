
1. 学习内容
来电流程
- modem接到来电消息，at指令上报到RILC层，再以socket上报到RILJ,然后RILJ进行处理
- BaseCommands中添加了注册CallStateChanged的方法
- 在GsmCdmaCallTracker的构造函数中调用它注册CallStateChanged
- 在本类的handleMessage中找到处理EVENT_CALL_STATE_CHANGE的语句
- 进入其父类Calltracker的pollCallsWhenSafe（）方法,携带消息(EVENT_POLL_CALLS_RESULT,调用了CommandsInterface.java的getCurrentCalls方法
- 该方法由RIL实现，再次与底层进行通信
- 根据EVENT_POLL_CALLS_RESULT找到了处理该消息的方法，GsmCdmaCallTracker中的handleMessage(),调用了handlePollCalls方法
- 进入 判断-> notify
- 进入notifyNewRingingConnection，其调用了父类Phone的 notifyNewRingingConnectionP(),进入 notifyNewRingingConnectionP（），发现接下来就是按照Notify流程进行通知注册者 notifyRegistrants()-> internalNotifyRegistrants()->交给handler进行sendMessage()等处理
- 在Phone中找到注册NewRingingConnection的方法registerForNewRingingConnection(),在里面添加了唯一的注册者Registrant
- 跟踪 registerForNewRingingConnection()，发现CallManager的 registerForPhoneStates方法和PstnIncomingCallNotifier的registerForNotifications方法注册了NewRingingConnection
- 先跟踪CallManager的 registerForPhoneStates方法，发现最终是每个Phone对象初始化时和GsmCdmaPhone初始化时就注册了PhoneStates方法，即会收到NewRingingConnection的通知
- 再跟踪PstnIncomingCallNotifier的registerForNotifications方法，发现该类初始化时就调用了PstnIncomingCallNotifier.java
- 回到PstnIncomingCallNotifier的registerForNotifications的方法，它注册的消息类型为EVENT_NEW_RINGING_CONNECTION
- 根据消息类型EVENT_NEW_RINGING_CONNECTION找到处理它的方法handleMessage
- 进入处理流程handleNewRingingConnection（）,发送了一个来电Intent
- 进入sendIncomingCallIntent，开始由TelecomManager处理来电消息addNewIncomingCall（）
- 进入TelecomManager的addNewIncomingCall（），接下来就是ITelecomService来处理了mCallIntentProcessorAdapter处理来电事件
- 进入ITelecomService的实现类TelecomServiceImpl.java的addNewIncomingCall方法。创建intent对象，熟悉的CallIntentProcessor处理来电事件
- 进入CallIntentProcessor的processIncomingCallIntent方法，开始交给CallsManager进行处理
- 进入CallsManager的processIncomingCallIntent方法,经过层层判断后开始调用Call的startCreateConnection()方法建立通话连接
- 进入Call的startCreateConnection()方法，调用 CreateConnectionProcessor的process来处理createConnection
- 下面和通话流程一致，进入CreateConnectionProcessor的process()方法，执行attemptNextPhoneAccount()，逐个检查每个账号是否满足通话条件，不满足则进行下一个账号检查，满足则调用ConnectionServiceWrapper.java的createConnection()方法，接下来就算获取callID,call类型， 建立connectionRequest等操作，最后调用 IConnectionService的createConnection()建立连接
- 进入 IConnectionService的实现类ConnectionService.java的 createConnection方法，根据消息类型MSG_CREATE_CONNECTION找出处理它的方法，里面调用了ConnectionService自己的createConnection方法
- 进入ConnectionService自己的createConnection方法根据connection类型执行不同的方法
- 进入onCreateIncomingConnection，类比呼叫流程找到TelephonyConnectionService.java的onCreateIncomingConnection()方法，调用了createConnectionFor（）方法
- 进入createConnectionFor方法，根据Phone类型来选建立哪种连接，以GsmConnection为例
- 进入GsmConnection，调用其父类的构造方法
- 进入其父类的构造方法，调用了setOriginalConnection()方法最终建立连接
- ????跟踪到Call对象的 handeCreateConnectionSuccess()方法，Call实现了CreateConnectionResponse接口的方法
- 进入onSuccessfulIncomingCall方法，它被CallsManager.java重写，执行来电拦截，黑名单等操作
- 进入IncomingCallFilterGraph的performFiltering()方法，调用CallFilterResultCallback的onCallFilteringComplete方法
- 进入CallFilterResultCallback的onCallFilteringComplete方法，找到它在CallsManager的实现,调用了本类的addCall方法
- 进入addCall()方法，调用CallsManagerListener的onCallAdded()方法
- 进入CallsManagerListener的onCallAdded()方法，发现为空，找到重写它的类InCallController.java，执行IInCallServicer.java的addCall()
- 进入IInCallServicer.java的addCall()方法，根据消息类型找到处理方法
- 在InCallService的 handleMessage中,调用了Phone的internalAddCall
- 进入Phone的internalAddCall，执行fireCallAdded（）触发“电话呼叫已添加”的事件
- 进入fireCallAdded，调用Phone的onCallAdded方法
- 找到它的重写的地方，最终位于InCallPresenter.java,至此来点流程结束

2、问题
调用了setOriginalConnection()最终建立连接时是怎么调用到handeCreateConnectionSuccess方法的，参考资料一带而过，没理解
3、明日计划
（1）继续分析来电流程和通话流程
（2）学习Telecom
（3）学习来电UI启动流程
