# 拨号流程
- DialpadFragment.java onClick() 执行 handleDialButtonPressed()
```
public void onClick(View view) {
    int resId = view.getId();
    if (resId == R.id.dialpad_floating_action_button) {
      view.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
      handleDialButtonPressed();
    } ...
```
```
  private void handleDialButtonPressed() {
   ...
        PreCall.start(getContext(), new CallIntentBuilder(number, CallInitiationType.Type.DIALPAD));
    ...
  }
```

- 进入PreCall.java start()方法 调用DialerUtils.startActivityWithErrorToast

```
  static void start(Context context, CallIntentBuilder builder) {
    DialerUtils.startActivityWithErrorToast(context, getIntent(context, builder));
  }
```
- 进入DialerUtils.startActivityWithErrorToast() 发现调用 placeCallOrMakeToast()
```
  public static void startActivityWithErrorToast(...) {
   ...
        if (shouldWarnForOutgoingWps(context, intent.getData().getSchemeSpecificPart())) {
         ...
                @Override
                public void onClick(DialogInterface dialog, int which) {
                  placeCallOrMakeToast(context, intent);
                }
              });
          ...
        } else {
          placeCallOrMakeToast(context, intent);
        }
      } 
  ...
  }
```
- 进入 placeCallOrMakeToast(),执行TelecomUtil.placeCall(context, intent)
- 进入TelecomUtil.placeCall(..)方法，发现先获取telecomManager,再调用其placeall()方法
```
  public static boolean placeCall(Context context, Intent intent) {
    ...
      getTelecomManager(context).placeCall(intent.getData(), intent.getExtras());
    ...
  }
```
- 进入TelecomManager的placeCall()方法，发现其获取了ITelecomService并调用其中的placeCall方法
```
    public void placeCall(Uri address, Bundle extras) {
        ITelecomService service = getTelecomService();
        ...
           service.placeCall(address, extras == null ? new Bundle() : extras,
             mContext.getOpPackageName(), mContext.getAttributionTag());
          ...
    }
```
- 进入ITelecomService的实现类TelecomServiceImpl的placeCall()方法，发现其t通过UserCallIntentProcessorFactory创建UserCallIntentProcessor组件，调用processInt处理呼叫

```
 public void placeCall(Uri handle, Bundle extras, String callingPackage,String callingFeatureId) {
         ...
  mUserCallIntentProcessorFactory.create(mContext, userHandle)
                                .processIntent(intent, callingPackage, isSelfManagedRequest,
                                 (hasCallAppOp && hasCallPermission)|| hasCallPrivilegedPermission,true);
                ...
```
- 进入UserCallIntentProcessor.java的processIntent()方法发现其先判断是否满足呼叫请求，若满足，则执行
   processOutgoingCallIntent()方法
```
  public void processIntent(Intent intent, String callingPackageName,boolean isSelfManaged, boolean canCallNonEmergency,boolean isLocalInvocation) {
        ...
        if (Intent.ACTION_CALL.equals(action) ||
                Intent.ACTION_CALL_PRIVILEGED.equals(action) ||
                Intent.ACTION_CALL_EMERGENCY.equals(action)) {
            processOutgoingCallIntent(intent, callingPackageName, isSelfManaged,
                    canCallNonEmergency, isLocalInvocation);
        }
    }
```
- 进入processOutgoingCallIntent方法,调用sendIntentToDestination()
```
  private void processOutgoingCallIntent(Intent intent, String callingPackageName,
            boolean isSelfManaged, boolean canCallNonEmergency,
            boolean isLocalInvocation) {
      ...
        sendIntentToDestination(intent, isLocalInvocation, callingPackageName);
    }

```
- 进入sendIntentToDestination()方法,发现其又获取并调用了TelecomManager中的方法--handleCallIntent
```
 private boolean sendIntentToDestination(Intent intent, boolean isLocalInvocation,
            String callingPackage) {
...
            TelecomManager tm = (TelecomManager)         mContext.getSystemService(Context.TELECOM_SERVICE);
            tm.handleCallIntent(intent, callingPackage);
...
    }
```
- 紧接着调用其service层的方法，service层的handleCallIntent调用了CallIntentProcessor.Adapter的.processOutgoingCallIntent()方法
```
@Override
        public void handleCallIntent(Intent intent, String callingPackage) {
...
                        mCallIntentProcessorAdapter.processOutgoingCallIntent(mContext,
                                mCallsManager, intent, callingPackage, mFeatureFlags);
...
        }
```
- 进入CallIntentProcessor.Adapter的processOutgoingCallIntent()方法，通过callManager的startOutgoingCall创建一个callFuture，接着创建call,然后new NewOutgoingCallIntentBroadcaster，调用其processCall()
```
   static void processOutgoingCallIntent(...) {
...
        NewOutgoingCallIntentBroadcaster broadcaster = new NewOutgoingCallIntentBroadcaster(...);
...
        CompletableFuture<Call> callFuture = callsManager.startOutgoingCall(...);
...
        callFuture.thenAccept((call) -> {
            if (call != null) {
                Log.continueSession(logSubsession, "CIP.sNOCI");
                try {
                    broadcaster.processCall(call, disposition);
                } finally {
                    Log.endSession();
                }
            }
        });
    }
```

- 进入NewOutgoingCallIntentBroadcaster的processCall()方法
  
