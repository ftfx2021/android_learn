# 拨号流程

## UI创建与事件处理
#### DialpadFragment
- DialpadFragment.java **onClick()** 执行 **handleDialButtonPressed()**   点击拨号按钮-》处理点击事件
```
public void onClick(View view) {
    int resId = view.getId();
    if (resId == R.id.dialpad_floating_action_button) {
      view.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
      handleDialButtonPressed();
    } ...
```
```
  private void handleDialButtonPressed() {
   ...
        PreCall.start(getContext(), new CallIntentBuilder(number, CallInitiationType.Type.DIALPAD));//拨号预处理.启动通话界面
    ...
  }
```
#### PreCall
> PreCall.java通常是用于处理通话前的准备工作的类。检查通话条件,初始化通话参数,启动通话界面
- 进入**PreCall.java start(**)方法 调用**DialerUtils.startActivityWithErrorToast()**    启动拨号界面

```
  static void start(Context context, CallIntentBuilder builder) {
    DialerUtils.startActivityWithErrorToast(context, getIntent(context, builder));
  }
```
#### DialerUtils
- 进入DialerUtils.startActivityWithErrorToast() 发现调用 **placeCallOrMakeToast()**  发起通话请求
```
  public static void startActivityWithErrorToast(...) {
   ...
        if (shouldWarnForOutgoingWps(context, intent.getData().getSchemeSpecificPart())) {
         ...
                @Override
                public void onClick(DialogInterface dialog, int which) {
                  placeCallOrMakeToast(context, intent);
                }
              });
          ...
        } else {
          placeCallOrMakeToast(context, intent);
        }
      } 
  ...
  }
```
- 进入 placeCallOrMakeToast(),执行**TelecomUtil.placeCall(context, intent)**            调用TelecomUtil发起通话请求

***
总结：用户输入电话-》单击拨号按钮-》处理拨号按钮点击事件-》显示通话界面
**通话UI启动结束,交给telecom处理**

***
## Telecom 处理通话意图
#### TelecomUtil
- 进入TelecomUtil.placeCall(..)方法， 获取telecomManager,调用**telecomManager的placeall()**方法
```
  public static boolean placeCall(Context context, Intent intent) {
    ...
      getTelecomManager(context).placeCall(intent.getData(), intent.getExtras());
    ...
  }
```

#### TelecomManager

- 进入TelecomManager的placeCall()方法，发现其获取了**ITelecomService并调用其中的placeCall方法**
```
    public void placeCall(Uri address, Bundle extras) {
        ITelecomService service = getTelecomService();
        ...
           service.placeCall(address, extras == null ? new Bundle() : extras,
             mContext.getOpPackageName(), mContext.getAttributionTag());
          ...
    }
```

#### ITelecomService处理
- 进入ITelecomService的实现类TelecomServiceImpl的placeCall()方法，发现其**通过UserCallIntentProcessorFactory创建UserCallIntentProcessor组件，调用processInt处理呼叫意图**

```
 public void placeCall(Uri handle, Bundle extras, String callingPackage,String callingFeatureId) {
         ...
  mUserCallIntentProcessorFactory.create(mContext, userHandle)
                                .processIntent(intent, callingPackage, isSelfManagedRequest,
                                 (hasCallAppOp && hasCallPermission)|| hasCallPrivilegedPermission,true);
                ...
```
#### UserCallIntentProcessor

> UserCallIntentProcessor 是一个跳板，它捕获用户的通话意图，并将这些意图转发给 CallIntentProcessor。这意味着 UserCallIntentProcessor 主要负责处理用户发起的通话意图，例如拨打电话或接听电话，并将这些意图转发给 CallIntentProcessor 进行进一步处理。这种设计可以确保用户的通话意图被正确地捕获并处理，同时也为系统提供了一个统一的接口来处理各种通话意图。

- 进入UserCallIntentProcessor.java的processIntent()方法发现其先判断是否满足呼叫请求，若满足，则**执行
   processOutgoingCallIntent()方法**
```
  public void processIntent(Intent intent, String callingPackageName,boolean isSelfManaged, boolean canCallNonEmergency,boolean isLocalInvocation) {
        ...
        if (Intent.ACTION_CALL.equals(action) ||
                Intent.ACTION_CALL_PRIVILEGED.equals(action) ||
                Intent.ACTION_CALL_EMERGENCY.equals(action)) {
            processOutgoingCallIntent(intent, callingPackageName, isSelfManaged,
                    canCallNonEmergency, isLocalInvocation);
        }
    }
```
- 进入processOutgoingCallIntent方法,**调用sendIntentToDestination()**
```
  private void processOutgoingCallIntent(Intent intent, String callingPackageName,
            boolean isSelfManaged, boolean canCallNonEmergency,
            boolean isLocalInvocation) {
      ...
        sendIntentToDestination(intent, isLocalInvocation, callingPackageName);
    }

```

- 进入sendIntentToDestination()方法,发现**回到了TelecomManager并调用其中的方法--handleCallIntent()**
```
 private boolean sendIntentToDestination(Intent intent, boolean isLocalInvocation,
            String callingPackage) {
...
            TelecomManager tm = (TelecomManager)         mContext.getSystemService(Context.TELECOM_SERVICE);
            tm.handleCallIntent(intent, callingPackage);
...
    }
```


#### CallIntentProcessor处理
> CallIntentProcessor 则是处理系统通话意图的类。它负责接收来自 UserCallIntentProcessor 的通话意图，并根据这些意图执行相应的通话操作。这意味着 CallIntentProcessor 是处理通话意图的核心部分

- 紧接着调用其service层的方法，service层的handleCallIntent调**用了CallIntentProcessor.Adapter的.processOutgoingCallIntent()方法**   适配器类：为了统一不同类的接口，使它们能够以统一的方式被调用
```
@Override
        public void handleCallIntent(Intent intent, String callingPackage) {
...
                        mCallIntentProcessorAdapter.processOutgoingCallIntent(mContext,
                                mCallsManager, intent, callingPackage, mFeatureFlags);
...
        }
```
#### CallIntentProcessor.Adapter
- 进入CallIntentProcessor.Adapter的processOutgoingCallIntent()方法，通过callManager的startOutgoingCall创建一个callFuture，接着创建call,然后**new NewOutgoingCallIntentBroadcaster，调用其processCall()**  广播新的外拨电话意图
```
   static void processOutgoingCallIntent(...) {
...
        NewOutgoingCallIntentBroadcaster broadcaster = new NewOutgoingCallIntentBroadcaster(...);
...
        CompletableFuture<Call> callFuture = callsManager.startOutgoingCall(...);
...
        callFuture.thenAccept((call) -> {
            if (call != null) {
                Log.continueSession(logSubsession, "CIP.sNOCI");
                try {
                    broadcaster.processCall(call, disposition);
                } finally {
                    Log.endSession();
                }
            }
        });
    }
```
#### NewOutgoingCallIntentBroadcaster
- 进入NewOutgoingCallIntentBroadcaster的processCall()方法,判断条件，满足**则执行CallImmediately方法**
```
  public void processCall(Call call, CallDisposition disposition) {
...
        if (!callRedirectionWithService) {
            callImmediately(disposition);
        }
...
    }
```
- 进入callImmediately()方法,**执行了placeOutgoingCallImmediately()**
```
    private void callImmediately(CallDisposition disposition) {
        placeOutgoingCallImmediately(mCall, disposition.callingAddress, null,
                speakerphoneOn, videoState);
    }
```
- 进入 placeOutgoingCallImmediately，**执行了 CallsManager中的placeOutgoingCall方法**
```
  private void placeOutgoingCallImmediately(Call call, Uri handle, GatewayInfo gatewayInfo,
            boolean speakerphoneOn, int videoState) {
        ...
        mCallsManager.placeOutgoingCall(call, handle, gatewayInfo, speakerphoneOn, videoState);
    }
```

## CallsManager创建通话连接

#### CallsManager
- 进入CallsManager中的placeOutgoingCall方法,**通知并调用Call.java的startCreateConnection()开始创建通话连接**
```
   @VisibleForTesting
    public void placeOutgoingCall(...){
...
                    notifyStartCreateConnection(call);
                    call.startCreateConnection(mPhoneAccountRegistrar);
    }
```
#### Call
--- 进入Call的startCreateConnection()方法，**调用 CreateConnectionProcessor.java的process()进行连接创建**
```
   void startCreateConnection(PhoneAccountRegistrar phoneAccountRegistrar) {
        mCreateConnectionProcessor.process();
    }
```
- 进入CreateConnectionProcessor.java的process()，**执行其attemptNextPhoneAccount()方法，开始选择电话账号来进行通话**
```
    @VisibleForTesting
    public void process() {
        Log.v(this, "process");
        clearTimeout();
        mAttemptRecords = new ArrayList<>();
        if (mCall.getTargetPhoneAccount() != null) {
            mAttemptRecords.add(new CallAttemptRecord(
                    mCall.getTargetPhoneAccount(), mCall.getTargetPhoneAccount()));
        }
        if (!mCall.isSelfManaged()) {
            adjustAttemptsForConnectionManager();
            adjustAttemptsForEmergency(mCall.getTargetPhoneAccount());
        }
        mAttemptRecordIterator = mAttemptRecords.iterator();
        attemptNextPhoneAccount();
    }
```


- 进入attemptNextPhoneAccount()，逐个检查每个账号是否满足通话条件，不满足则进行下一个账号检查，满足则建立连接服务并**调用 ConnectionServiceWrapper的 createConnection()进行创建连接**
```
   private void attemptNextPhoneAccount() {
        CallAttemptRecord attempt = null;
        if (...) {
            attempt = mAttemptRecordIterator.next();
            if (...)
                attemptNextPhoneAccount();
            }
        }
...
        if (mCallResponse != null && attempt != null) {
                        mCall.setConnectionService(mService);
...
                        mService.createConnection(mCall, CreateConnectionProcessor.this);
             ...
        } 
    }
```
#### ConnectionServiceWrapper
>ConnectionServiceWrapper 在 Android 通话框架中起到了桥梁的作用，它负责处理和转发通话事件，确保通话应用能够正确地与电信子系统进行交互。这是 Android 通话框架中处理通话操作的关键组件，它使得通话应用能够更方便地与电信子系统进行交互，从而提供更好的用户体验。

- 进入 ConnectionServiceWrapper的 createConnection(),进入回调函数，逐步判断**后执行IConnectionService的createConnection()方法**
```
   public void createConnection(final Call call, final CreateConnectionResponse response) {
        BindCallback callback = new BindCallback() {
            @Override
            public void onSuccess() {
            ...
                    mServiceInterface.createConnection()
            ...
            }
            
            @Override
            public void onFailure() {
            ...
            }
        };
...
    }

```
#### IConnectionService
- 进入IConnectionService的实现类ConnectionService.java找到重写IConnectionService中的createConnection()的方法，发现最终其**创建了一个消息类型为 MSG_CREATE_CONNECTION的消息对象，并附加数据，发送给 Handler 对象的消息队列。**
```
   public void createConnection(...)
            ...
                mHandler.obtainMessage(MSG_CREATE_CONNECTION, args).sendToTarget();
            
        }
```
- 根据MSG_CREATE_CONNECTION找到了用于处理Handle的 **handleMessage()方法,**其调用了**本类的createConnection()方法**
```
    private final Handler mHandler = new Handler(Looper.getMainLooper()) {
 @Override
        public void handleMessage(Message msg) {
 case MSG_CREATE_CONNECTION: {
                 
                            createConnection(...);
    }
}
```
- 进入createConnection()方法,**根据Connection类型来处理创建连接还是来电连接，**
```
private void createConnection(...) {
            connection = isUnknown ? onCreateUnknownConnection(callManagerAccount, request)
                    : isIncoming ? onCreateIncomingConnection(callManagerAccount, request)
                    : onCreateOutgoingConnection(callManagerAccount, request);
        }
```
### 发起呼叫连接
#### TelephonyConnectionService
- 进入onCreateOutgoingConnection()，发现返回值为null，但是根据 createConnection(...)方法里的语句，返回值不可能只为null，于是寻找重写了它的方法，发现排除了测试类，只有在TelephonyConnectionService.java中重写过onCreateOutgoingConnection()，进入,发现调用了**本类的placeOutgoingConnection()发起呼出连接**
```
 public Connection onCreateOutgoingConnection(){
     if (success) {
placeOutgoingConnection(request, resultConnection,phone);
}
```
- 进入 placeOutgoingConnection(),发现其最终2次调用了自己的重载方法，进入最终的发起呼叫连接方法placeOutgoingConnection(),最终调用了**底层的PhoneInternalInterface.java的接口，即将和RIL进行交互**
```
  private void placeOutgoingConnection(){
originalConnection = phone.dial(...);
}
```
#### PhoneInternalInterface
- 找到PhoneInternalInterface.java的实现类GsmCdmaPhone.java的dial()方法,**调用了 dialInternal()方法**
```
  public Connection dial(..) {
...
 return dialInternal(dialString, dialArgs);
}
```
- 进入dialInternal()方法，接着**调用GsmCdmaCallTracker.java的dial()**
```
   protected Connection dialInternal(...)
            return mCT.dial(newDialString, dialArgs);
    }
```
#### GsmCdmaCallTracker
> 负责跟踪和管理 GSM 和 CDMA 通话状态,创建、管理通话连接，跟踪通话状态...
- 进入GsmCdmaCallTracker.java的dial()，根据Phone类型（Gsm还是Cdma）调用不同的dial,以 **dialGsm**为例
```
      public Connection dial(String dialString, DialArgs dialArgs) throws CallStateException {
        if (isPhoneTypeGsm()) {
            return dialGsm(dialString, dialArgs);
        } else {
            return dialCdma(dialString, dialArgs);
        }
    }

```
- 进入dialGsm()方法，最终**调用了命令接口层CommandsInterface**，该接口由RIL和BaseCommands实现，BaseCommands为抽象类，封装了RIL的方法
```
 public synchronized Connection dialGsm(String dialString, DialArgs dialArgs){
  mCi.dial(mPendingMO.getAddress(), mPendingMO.isEmergencyCall(),
                    mPendingMO.getEmergencyNumberInfo(), mPendingMO.hasKnownUserIntentEmergency(),
                    clirMode, uusInfo, obtainCompleteMessage());
}
```
- 进入其实现类**RIL.java,RILJ开始向RILC发送消息，最终到达了modem并和它进行通信**
