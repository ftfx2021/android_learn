# 拨号流程
- DialpadFragment.java **onClick()** 执行 **handleDialButtonPressed()**
```
public void onClick(View view) {
    int resId = view.getId();
    if (resId == R.id.dialpad_floating_action_button) {
      view.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
      handleDialButtonPressed();
    } ...
```
```
  private void handleDialButtonPressed() {
   ...
        PreCall.start(getContext(), new CallIntentBuilder(number, CallInitiationType.Type.DIALPAD));
    ...
  }
```

- 进入**PreCall.java start(**)方法 调用**DialerUtils.startActivityWithErrorToast()**

```
  static void start(Context context, CallIntentBuilder builder) {
    DialerUtils.startActivityWithErrorToast(context, getIntent(context, builder));
  }
```
- 进入DialerUtils.startActivityWithErrorToast() 发现调用 **placeCallOrMakeToast()**
```
  public static void startActivityWithErrorToast(...) {
   ...
        if (shouldWarnForOutgoingWps(context, intent.getData().getSchemeSpecificPart())) {
         ...
                @Override
                public void onClick(DialogInterface dialog, int which) {
                  placeCallOrMakeToast(context, intent);
                }
              });
          ...
        } else {
          placeCallOrMakeToast(context, intent);
        }
      } 
  ...
  }
```
- 进入 placeCallOrMakeToast(),执行**TelecomUtil.placeCall(context, intent)**
- 进入TelecomUtil.placeCall(..)方法，发现先获取telecomManager,再调用**telecomManager的placeall()**方法
```
  public static boolean placeCall(Context context, Intent intent) {
    ...
      getTelecomManager(context).placeCall(intent.getData(), intent.getExtras());
    ...
  }
```
- 进入TelecomManager的placeCall()方法，发现其获取了**ITelecomService并调用其中的placeCall方法**
```
    public void placeCall(Uri address, Bundle extras) {
        ITelecomService service = getTelecomService();
        ...
           service.placeCall(address, extras == null ? new Bundle() : extras,
             mContext.getOpPackageName(), mContext.getAttributionTag());
          ...
    }
```
- 进入ITelecomService的实现类TelecomServiceImpl的placeCall()方法，发现其**通过UserCallIntentProcessorFactory创建UserCallIntentProcessor组件，调用processInt处理呼叫**

```
 public void placeCall(Uri handle, Bundle extras, String callingPackage,String callingFeatureId) {
         ...
  mUserCallIntentProcessorFactory.create(mContext, userHandle)
                                .processIntent(intent, callingPackage, isSelfManagedRequest,
                                 (hasCallAppOp && hasCallPermission)|| hasCallPrivilegedPermission,true);
                ...
```
- 进入UserCallIntentProcessor.java的processIntent()方法发现其先判断是否满足呼叫请求，若满足，则**执行
   processOutgoingCallIntent()方法**
```
  public void processIntent(Intent intent, String callingPackageName,boolean isSelfManaged, boolean canCallNonEmergency,boolean isLocalInvocation) {
        ...
        if (Intent.ACTION_CALL.equals(action) ||
                Intent.ACTION_CALL_PRIVILEGED.equals(action) ||
                Intent.ACTION_CALL_EMERGENCY.equals(action)) {
            processOutgoingCallIntent(intent, callingPackageName, isSelfManaged,
                    canCallNonEmergency, isLocalInvocation);
        }
    }
```
- 进入processOutgoingCallIntent方法,**调用sendIntentToDestination()**
```
  private void processOutgoingCallIntent(Intent intent, String callingPackageName,
            boolean isSelfManaged, boolean canCallNonEmergency,
            boolean isLocalInvocation) {
      ...
        sendIntentToDestination(intent, isLocalInvocation, callingPackageName);
    }

```
- 进入sendIntentToDestination()方法,发现**其又获取并调用了TelecomManager中的方法--handleCallIntent()**
```
 private boolean sendIntentToDestination(Intent intent, boolean isLocalInvocation,
            String callingPackage) {
...
            TelecomManager tm = (TelecomManager)         mContext.getSystemService(Context.TELECOM_SERVICE);
            tm.handleCallIntent(intent, callingPackage);
...
    }
```
- 紧接着调用其service层的方法，service层的handleCallIntent调**用了CallIntentProcessor.Adapter的.processOutgoingCallIntent()方法**
```
@Override
        public void handleCallIntent(Intent intent, String callingPackage) {
...
                        mCallIntentProcessorAdapter.processOutgoingCallIntent(mContext,
                                mCallsManager, intent, callingPackage, mFeatureFlags);
...
        }
```
- 进入CallIntentProcessor.Adapter的processOutgoingCallIntent()方法，通过callManager的startOutgoingCall创建一个callFuture，接着创建call,然后**new NewOutgoingCallIntentBroadcaster，调用其processCall()**
```
   static void processOutgoingCallIntent(...) {
...
        NewOutgoingCallIntentBroadcaster broadcaster = new NewOutgoingCallIntentBroadcaster(...);
...
        CompletableFuture<Call> callFuture = callsManager.startOutgoingCall(...);
...
        callFuture.thenAccept((call) -> {
            if (call != null) {
                Log.continueSession(logSubsession, "CIP.sNOCI");
                try {
                    broadcaster.processCall(call, disposition);
                } finally {
                    Log.endSession();
                }
            }
        });
    }
```

- 进入NewOutgoingCallIntentBroadcaster的processCall()方法,判断条件，满足**则执行CallImmediately方法**
```
  public void processCall(Call call, CallDisposition disposition) {
...
        if (!callRedirectionWithService) {
            callImmediately(disposition);
        }
...
    }
```
- 进入callImmediately()方法,**执行了placeOutgoingCallImmediately()**
```
    private void callImmediately(CallDisposition disposition) {
        placeOutgoingCallImmediately(mCall, disposition.callingAddress, null,
                speakerphoneOn, videoState);
    }
```
- 进入 placeOutgoingCallImmediately，**执行了 CallsManager中的placeOutgoingCall方法**
```
  private void placeOutgoingCallImmediately(Call call, Uri handle, GatewayInfo gatewayInfo,
            boolean speakerphoneOn, int videoState) {
        ...
        mCallsManager.placeOutgoingCall(call, handle, gatewayInfo, speakerphoneOn, videoState);
    }
```
- 进入CallsManager中的placeOutgoingCall方法,**通知并调用Call.java的startCreateConnection()开始创建通话连接**
```
   @VisibleForTesting
    public void placeOutgoingCall(...){
...
                    notifyStartCreateConnection(call);
                    call.startCreateConnection(mPhoneAccountRegistrar);
    }
```
--- 进入Call的startCreateConnection()方法，**调用 CreateConnectionProcessor.java的process()进行连接创建**
```
   void startCreateConnection(PhoneAccountRegistrar phoneAccountRegistrar) {
        mCreateConnectionProcessor.process();
    }
```
- 进入CreateConnectionProcessor.java的process()，**执行其attemptNextPhoneAccount()方法，开始选择电话账号来进行通话**
```
    @VisibleForTesting
    public void process() {
        Log.v(this, "process");
        clearTimeout();
        mAttemptRecords = new ArrayList<>();
        if (mCall.getTargetPhoneAccount() != null) {
            mAttemptRecords.add(new CallAttemptRecord(
                    mCall.getTargetPhoneAccount(), mCall.getTargetPhoneAccount()));
        }
        if (!mCall.isSelfManaged()) {
            adjustAttemptsForConnectionManager();
            adjustAttemptsForEmergency(mCall.getTargetPhoneAccount());
        }
        mAttemptRecordIterator = mAttemptRecords.iterator();
        attemptNextPhoneAccount();
    }
```
- 进入attemptNextPhoneAccount()，逐个检查每个账号是否满足通话条件，不满足则进行下一个账号检查，满足则建立连接服务并**调用 ConnectionServiceWrapper的 createConnection()进行创建连接**
```
   private void attemptNextPhoneAccount() {
        CallAttemptRecord attempt = null;
        if (...) {
            attempt = mAttemptRecordIterator.next();
            if (...)
                attemptNextPhoneAccount();
            }
        }
...
        if (mCallResponse != null && attempt != null) {
                        mCall.setConnectionService(mService);
...
                        mService.createConnection(mCall, CreateConnectionProcessor.this);
             ...
        } 
    }
```
- 进入 ConnectionServiceWrapper的 createConnection(),进入回调函数，逐步判断**后执行IConnectionService的createConnection()方法**
```
   public void createConnection(final Call call, final CreateConnectionResponse response) {
        BindCallback callback = new BindCallback() {
            @Override
            public void onSuccess() {
            ...
                    mServiceInterface.createConnection()
            ...
            }
            
            @Override
            public void onFailure() {
            ...
            }
        };
...
    }

```
- 进入行IConnectionService的实现类ConnectionService.java找到重写IConnectionService中的createConnection()的方法，发现最终其**创建了一个消息类型为 MSG_CREATE_CONNECTION的消息对象，并附加数据，发送给 Handler 对象的消息队列。**
```
   public void createConnection(...)
            ...
                mHandler.obtainMessage(MSG_CREATE_CONNECTION, args).sendToTarget();
            
        }
```
- 根据MSG_CREATE_CONNECTION找到了用于处理Handle的 **handleMessage()方法,**其调用了**本类的createConnection()方法**
```
    private final Handler mHandler = new Handler(Looper.getMainLooper()) {
 @Override
        public void handleMessage(Message msg) {
 case MSG_CREATE_CONNECTION: {
                 
                            createConnection(...);
    }
}
```
- 进入createConnection()方法,**根据Connection类型来处理创建连接还是来电连接，**
```
private void createConnection(...) {
            connection = isUnknown ? onCreateUnknownConnection(callManagerAccount, request)
                    : isIncoming ? onCreateIncomingConnection(callManagerAccount, request)
                    : onCreateOutgoingConnection(callManagerAccount, request);
        }
```
- 进入onCreateOutgoingConnection()，发现返回值为null，但是根据 createConnection(...)方法里的语句，返回值不可能只为null，于是寻找重写了它的方法，发现排除了测试类，只有在TelephonyConnectionService.java中重写过onCreateOutgoingConnection()，进入,发现调用了**本类的placeOutgoingConnection()发起呼出连接**
```
 public Connection onCreateOutgoingConnection(){
     if (success) {
placeOutgoingConnection(request, resultConnection,phone);
}
```
- 进入 placeOutgoingConnection(),发现其最终2次调用了自己的重载方法，进入最终的发起呼叫连接方法placeOutgoingConnection(),最终调用了**底层的PhoneInternalInterface.java的接口，即将和RIL进行交互**
```
  private void placeOutgoingConnection(){
originalConnection = phone.dial(...);
}
```
- 找到PhoneInternalInterface.java的实现类GsmCdmaPhone.java的dial()方法,**调用了 dialInternal()方法**
```
  public Connection dial(..) {
...
 return dialInternal(dialString, dialArgs);
}
```
- 进入dialInternal()方法，接着**调用GsmCdmaCallTracker.java的dial()**
```
   protected Connection dialInternal(...)
            return mCT.dial(newDialString, dialArgs);
    }
```
- 进入GsmCdmaCallTracker.java的dial()，根据Phone类型（Gsm还是Cdma）调用不同的dial,以 **dialGsm**为例
```
      public Connection dial(String dialString, DialArgs dialArgs) throws CallStateException {
        if (isPhoneTypeGsm()) {
            return dialGsm(dialString, dialArgs);
        } else {
            return dialCdma(dialString, dialArgs);
        }
    }

```
- 进入dialGsm()方法，最终**调用了命令接口层CommandsInterface**，该接口由RIL和BaseCommands实现，BaseCommands为抽象类，封装了RIL的方法
```
 public synchronized Connection dialGsm(String dialString, DialArgs dialArgs){
  mCi.dial(mPendingMO.getAddress(), mPendingMO.isEmergencyCall(),
                    mPendingMO.getEmergencyNumberInfo(), mPendingMO.hasKnownUserIntentEmergency(),
                    clirMode, uusInfo, obtainCompleteMessage());
}
```
- 进入其实现类**RIL.java,RILJ开始向RILC发送消息，最终到达了modem并和它进行通信**
