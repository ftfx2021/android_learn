
一、学习内容
1、拨号流程(APP--RILJ)
（1）拨号界面至TelecomServicel 
- DialpadFragment.java onClick() 执行 handleDialButtonPressed()
- 进入PreCall.java start()方法 调用DialerUtils.startActivityWithErrorToast()
- 进入DialerUtils.startActivityWithErrorToast() 发现调用 placeCallOrMakeToast()
- 进入 placeCallOrMakeToast(),执行TelecomUtil.placeCall(context, intent)
（2）TelecomServicel至CallsManager，逐步传递包装了拨号请求的intent对象，发起呼出电话
- 进入TelecomUtil.placeCall(..)方法，发现先获取telecomManager,再调用telecomManager的**placeall()**方法
- 进入TelecomManager的placeCall()方法，发现其获取了ITelecomService并调用其中的**placeCall（）**方法
- 进入ITelecomService的实现类TelecomServiceImpl的**placeCall()**方法，发现其通过UserCallIntentProcessorFactory创建UserCallIntentProcessor组件，调用processInt处理呼叫
- 进入UserCallIntentProcessor.java的processIntent()方法发现其先判断是否满足呼叫请求，若满足，则执行 processOutgoingCallIntent()方法
- 进入processOutgoingCallIntent方法,调用sendIntentToDestination()
- 进入sendIntentToDestination()方法,发现其又获取并调用了TelecomManager中的方法--handleCallIntent()
- 紧接着调用其service层的方法，service层的handleCallIntent调用了CallIntentProcessor.Adapter的.processOutgoingCallIntent()方法

（3）CallsManager到IConnectionService ，创建更新保存Call对象，建立通话连接服务，继续传递拨号请求
- 进入CallIntentProcessor.Adapter的processOutgoingCallIntent()方法，通过callManager的startOutgoingCall创建一个callFuture，接着创建call,然后new NewOutgoingCallIntentBroadcaster，调用其processCall()
- 进入NewOutgoingCallIntentBroadcaster的processCall()方法,判断条件，满足则执行CallImmediately方法
- 进入callImmediately()方法,执行了placeOutgoingCallImmediately()
- 进入 placeOutgoingCallImmediately，执行了 CallsManager中的placeOutgoingCall方法

- 进入CallsManager中的placeOutgoingCall方法,通知并调用Call.java的startCreateConnection()开始创建通话连接
- 进入Call的startCreateConnection()方法，调用 CreateConnectionProcessor.java的process()进行连接创建
- 进入CreateConnectionProcessor.java的process()，执行其attemptNextPhoneAccount()方法，开始选择电话账号来进行通话
- 进入attemptNextPhoneAccount()，逐个检查每个账号是否满足通话条件，不满足则进行下一个账号检查，满足则建立连接服务并调用 ConnectionServiceWrapper的 createConnection()进行创建连接

（4）IConnectionService服务响应至RILF发起拨号请求
- 进入 ConnectionServiceWrapper的 createConnection(),进入回调函数，逐步判断后执行IConnectionService的createConnection()方法
- 进入IConnectionService的实现类ConnectionService.java找到重写IConnectionService中的createConnection()的方法，发现最终其创建了一个消息类型为 MSG_CREATE_CONNECTION的消息对象，并附加数据，发送给 Handler 对象的消息队列。
- 根据MSG_CREATE_CONNECTION找到了用于处理Handle的 handleMessage()方法,其调用了本类的createConnection()方法
- 进入createConnection()方法,根据Connection类型来处理创建连接还是来电连接，
- 进入onCreateOutgoingConnection()，发现返回值为null，但是根据 createConnection(...)方法里的语句，返回值不可能只为null，于是寻找重写了它的方法，发现排除了测试类，只有在TelephonyConnectionService.java中重写过onCreateOutgoingConnection()，进入,发现调用了本类的placeOutgoingConnection()发起呼出连接
- 进入 placeOutgoingConnection(),发现其最终2次调用了自己的重载方法，进入最终的发起呼叫连接方法placeOutgoingConnection(),最终调用了底层的PhoneInternalInterface.java的接口，即将和RIL进行交互
- 找到PhoneInternalInterface.java的实现类GsmCdmaPhone.java的dial()方法,调用了 dialInternal()方法
- 进入dialInternal()方法，接着调用GsmCdmaCallTracker.java的dial()
- 进入GsmCdmaCallTracker.java的dial()，根据Phone类型（Gsm还是Cdma）调用不同的dial,以 dialGsm为例
- 进入dialGsm()方法，最终调用了命令接口层CommandsInterface，该接口由RIL和BaseCommands实现，BaseCommands为抽象类，封装了RIL的方法
- 进入其实现类RIL.java,RILJ开始向RILC发送消息，最终到达了modem并和它进行通信

2、接口扩展
根据教程，从CommandsInterfance到App扩展一个setValueToModem()方法进行逐步调用
从RIL到APP消息流程总结
RIL->Phone mNotifier.notifySetValueDone->DefaultPhoneNotifier mTelephonyRegistryMgr.nofifySetValueDone-> TelephonyRegistryManager sRegistry.onSetValueDone -> ITelephonyRegistry r.callback.onSetValueDone -> IPhoneStateListener Message.obtain() ->Phone handlerMessage PhoneStateListener.this.setValueDone ->APP调用

二、明日计划
1、深入分析通话流程，了解其中placeOutgoingCall，TelecomAdapter等关键逻辑
2、分析来电流程
