安卓端下放数据
  ```
typedef enum {
    OFF,
    ON
} Switch;
  ```
  ### 电器控制数据
  ```
  typedef struct {
    int color_r;
    int color_g;
    int color_b;
    Switch state;
} LEDData;
  typedef struct {
  Switch state;
  Switch fan_speed;
  Switch fan-direction;
} FanData;

```
```
typedef struct {
  Switch bedroom_led;
  LEDData livingrom_led;
  Switch tolit_led;
  Switch curtain_switch;
  FanData fan;
  Switch alarm_switch
} ApplicationGroup;

ApplicationGroup applications;
```
  ### 情景模式
  ```
typedef enum {
    EMPTY = 0,
    MOVIE = 1,
    SLEEP = 2,
    AWAY = 3,
    HOME = 4,
    CUSTOM = 5
} SceneMode;
SceneMode current_mode = EMPTY;
  ```
### 自定义模式数据
  ```
typedef struct {
    Switch bedroom_light;
    Switch living_room_light;
    Switch tolit_light;
    Switch curtain;
    Switch fan;
    Switch alarm;
} CustomModeData;

CustomModeData customModeData
  ```
### 自动化模式数据
```
typedef struct {
    AutoController fan_temperature_high; // 温度高阈值
    AutoController fan_temperature_low; // 温度高阈值
    AutoController led_light_high;
    AutoController led_light_low;
    AutoController curtain_light_low;
    AutoController curtain_light_high;
    AutoController alarm_ppm;
} AutoModeData;
typedef struct{
  int value;
  Switch state;
}AutoController
AutoModeData autoModeData;
```

### 自动化控制
```
void auto_mode_check(){
if(autoModeData.fan_temperature_high.state == ON){
  if(temperature > autoModeData.fan_temperature_high.value){
  applications.fan.state = ON;
}
if(autoModeData.fan_temperature_low.state == ON){
  if(temperature < autoModeData.fan_temperature_low.value){
  applications.fan.state = OFF;
}
if(autoModeData.led_light_high.state == ON){
  if(temperature > autoModeData.led_light_high.value){
  applications.livingrom_led.state = ON;
}
if(autoModeData.led_light_low.state == ON){
  if(temperature < autoModeData.led_light_low.value){
  applications.livingrom_led.state = OFF;
}
if(autoModeData.curtain_light_high.state == ON){
  if(temperature > autoModeData.curtain_light_high.value){
  applications.curtain_switch = OFF;
}
if(autoModeData.curtain_light_low.state == ON){
  if(temperature < autoModeData.fan_temperature_low.value){
  applications.curtain_switch = LOW;
}
if(autoModeData.alarm_ppm.state== ON){
  if(ppm > (autoModeData.alarm_ppm.value){
  applications.alarm_switch = ON;
  open_beep();
}


}

}
```
### 用户上线\下线
```
  typedef struct{
  char * username;
  char * real_name;
  int  state;
}UserState;
UserState userState
```
### 闹钟
```
  typedef struct{
  char * time;
  Switch state;
  }AlarmClock
  AlarmClock alarmClock
```
### 定时事件
```
  typedef struct{
  char * name;
  char * time;
  Switch state;
}TimingEvent;

typedef struct{
TimingEvent event1;
TimingEvent event2;
TimingEvent event3;

}TimingEventGroup;
TimingEventGroup timingEventGroup;
//处理定时事件
void deal_timing_event(char * eventName);{
  switch(eventName){
    case "BEDROOM_ON":applications.bedroom_led=ON;  sendData() ;break;
    case "BEDROOM_OFF":applications.bedroom_led=OFF; ;break;
    case "LIVINGROOM_ON":applications.livingrom_led.state=ON  ; break;
    case "LIVINGROOM_OFF": applications.livingrom_led.state=OFF ; break;
    case "TOTAIL_ON": applications.tolit_led = ON ; break;
    case "TOTAIL_OFF": applications.tolit_led = OFF ; break;
    case "FAN_ON": application.FanData.switch = ON ;break;
    case "FAN_OFF": application.FanData.switch = OFF ;break;
    case "CURTAIN_ON": applications.curtain_switch = ON ;break;
    case "CURTAIN_OFF":applications.curtain_switch = OFF  ;break;
default:break;
}

}
void timing_event_check(){
  Switch eventState1 = timingEventGroup.event1.state;
   Switch eventState2 = timingEventGroup.event2.state;
 Switch eventState3 = timingEventGroup.event3.state;
char * time1 = timingEventGroup.event1.time;
char * time2 = timingEventGroup.event2.time;
char * time3 = timingEventGroup.event3.time;
  if(currentTime = time1&&eventState1 == ON ){
  char * eventName1 =  timingEventGroup.event1.name;
  deal_timing_event(eventName1);
}
  if(currentTime = time2&&eventState2 == ON){
 char * eventName2 =  timingEventGroup.event2.name;
  deal_timing_event(eventName2);
}
  if(currentTime = time3&&eventState3 == ON){
 char * eventName3 =  timingEventGroup.event3.name;
  deal_timing_event(eventName3);
}
  
}
//闹钟
void alarm_clock_check(){

if(currentTime = AlarmClock.time&&AlarmClock.state==ON){
  open_bean();
 }

}

fun open_beep(){
if()
beep=1;
delay(1000);
beep=0;
}
```
###
### 情景模式
```
  fun scene_mode_control( ){
  switch(current_mode){
  case MOVIE:mode_movie();break;
  case SLEEP:mode_sleep();break;
  case AWAY:mode_away();break;
  case HOME:mode_home();break;
  case CUSTOM:mode_custom();break;
  default:break;
}
}
```
#### 睡眠模式
  - 卧室灯开启，其余灯关闭，窗帘关闭.风扇不动
```
  void mode_sleep(){
applications.bedroom_led=ON;
sendData();
applications.livingrom_led.state = OFF
sendData()
applications.tolit_led = OFF
sendData()
applications.curtain_switch = OFF
sendData()
/*控制电器，发送数据*/
  sendData()
}
  
```
#### 离家模式
  - 所有设备关闭
```
  void mode_away(){
applications.bedroom_led=OFF;
sendData();
applications.livingrom_led.state = OFF
sendData()
applications.tolit_led = OFF
sendData()
applications.curtain_switch = OFF
sendData()
application.FanData.state = OFF
sendData()
  
}
```
#### 观影模式
  - 客厅LED调为暖色
  - 窗帘关闭
  - 其余灯关闭
```
  void mode_movie(){
applications.bedroom_led=OFF;
sendData();
applications.livingrom_led.state = ON;
application.livingroom_led.color_r = 255;
application.livingroom_led.color_g = 220;
application.livingroom_led.color_b = 170;
sendData()
applications.tolit_led = OFF
sendData()
applications.curtain_switch = OFF
sendData()
}
```
#### 回家模式
  - 根据时间/温度决定是否开灯，开风扇
```
void mode_home(){
if(temperature > autoModeData.fan_temperature.high && autoModeData.fan_temperature.state_high = ON){
  applications.FanData.state = ON
  sendData()
}
if(temperature < autoModeData.fan_temperature.low && autoModeData.fan_temperature.state_low = ON){
  applications.FanData.state = OFF
  sendData()
}
if(light > autoModeData.led_light.high && autoModeData.led_light.state_high = ON){
  applications.livingrom_led.state = ON
  sendData()
}
if(light < autoModeData.led_light.low && autoModeData.led_light.state_low = ON){
  applications.livingrom_led.state = OFF
  sendData()
}
if(light > autoModeData.curtain_light.high && autoModeData.curtain_light.state_high = ON){
  applications.curtain_switch = ON
  sendData()
}
if(light < autoModeData.curtain_light.low && autoModeData.curtain_light.state_low = ON){
  applications.curtain_switch = OFF
  sendData()
}

}
```
#### 自定义模式
```
void mode_custom(){
applications.bedroom_led=customModeData.bedroom_light;
sendData();
applications.livingrom_led.state = customModeData.living_room_light;
sendData();
applications.tolit_led = customModeData.tolit_light;
sendData();
applications.curtain_switch = customModeData.curtain;
sendData();
application.FanData.switch = customModeData.fan;
sendData();
application.alarm_switch = customModeData.alarm;
sendData();
  
}
```

### 数据解析
收到含smart_set的数据包->解析->更新数据updateData()->发送ACK:{stm32_set:{recv:ok}}

```
    cJSON* smart_set = cJSON_GetObjectItem(root, "smart_set");
    if (smart_set == NULL) {
        printf("Error: smart_set not found in JSON\n");
        cJSON_Delete(root);
        return NULL;
    }
```
- 用户数据
```
    cJSON* userState = cJSON_GetObjectItem(smart_set, "userState");
    if (userState == NULL) {
        printf("Error: userState not found in JSON\n");
        cJSON_Delete(root);
        return NULL;
    }else{
   userState->username = strdup(cJSON_GetObjectItem(userState, "username")->valuestring);
    userState->real_name = strdup(cJSON_GetObjectItem(userState, "realName")->valuestring);
    userState->state = cJSON_GetObjectItem(userState, "state")->valueint;
}
```
- autoController
```
   cJSON* autoController = cJSON_GetObjectItem(smart_set, "autoController");
    if (autoController == NULL) {
        printf("Error: autoController not found in JSON\n");
        cJSON_Delete(root);
        return NULL;
    }else{
    char *autoControllerName = strdup(cJSON_GetObjectItem(autoController, "name")->valuestring);
    int value = cJSON_GetObjectItem(autoController, "value")->valueint;
    int state = cJSON_GetObjectItem(autoController, "state")->valueint;
switch (autoModeName){
case "fan_temperature_high":{
  autoModeData->fan_temperature_high.value = value;
  autoModeData->fan_temperature_high.state = state;
  };break;
case "fan_temperature_low":{
  autoModeData->fan_temperature_low.value = value;
  autoModeData->fan_temperature_low.state = state;
  };break;
case "curtain_light_high":{
  autoModeData->curtain_light_high.value = value;
  autoModeData->curtain_light_high.state = state;
  };break;
case "curtain_light_low":{
 autoModeData->curtain_light_low.value = value;
  autoModeData->curtain_light_low.state = state;
}
case "led_light_low":{
 autoModeData->led_light_low.value = value;
  autoModeData->led_light_low.state = state;
}
case "led_light_high":{
 autoModeData->led_light_high.value = value;
  autoModeData->led_light_high.state = state;
}
case "alarm_ppm":{
  autoModeData->alarm_ppm.value = value;
  autoModeData->alarm_ppm.state = state;
  };break;
  else:break;
  }
}
```
- 闹钟
```
 cJSON* alarmClock = cJSON_GetObjectItem(smart_set, "alarmClock");
    if (alarmClock == NULL) {
        printf("Error: alarmClock not found in JSON\n");
        cJSON_Delete(root);
        return NULL;
    }else{

 alarmClock->time = strdup(cJSON_GetObjectItem(alarmClock, "time")->valuestring);
    alarmClock->enable = cJSON_GetObjectItem(alarmClock, "enable")->valueint;
}
```
- 定时事件
```
TimingEventGroup.event1
  typedef struct{
  char * name;
  char * time;
  Switch state;
}TimingEvent;

  cJSON* timerEvent = cJSON_GetObjectItem(smart_set, "timerEvent");
    if (timerEvent == NULL) {
        printf("Error: timerEvent not found in JSON\n");
        cJSON_Delete(root);
        return NULL;
    }else{
    int id = cJSON_GetObjectItem(timerEvent, "id")->valueint;
    char * time = strdup(cJSON_GetObjectItem(timerEvent, "time")->valuestring);
    char *eventName = strdup(cJSON_GetObjectItem(timerEvent, "eventName")->valuestring);
    int state = cJSON_GetObjectItem(timerEvent, "state")->valueint;
switch(id){
case 1:{
timingEventGroup.event1.name = name;
timingEventGroup.event1.time = time
timingEventGroup.event1.state = state;
};break;
case 2:{
timingEventGroup.event2.name = name;
timingEventGroup.event2.time = time
timingEventGroup.event2.state = state;
};break;
case 3:{
timingEventGroup.event3.name = name;
timingEventGroup.event3.time = time
timingEventGroup.event3.state = state;
};break;
else:break;


}

}
```
### 主函数
int main(){

初始化:{
  ①各个传感器初始化
  ②指纹模块等硬件初始化
  ③esp8266初始化
  ④阿里云初始化
  }
  身份验证
  验证成功：发送ack提示设备上线
while(1){
response();
update_environment_data();
alarm_clock_check();
auto_mode_check();


}
}

```
while(1){

update_environment_data();
delay_ms(10);
response(1);
delay_ms(10);
alarm_clock_check();
delay_ms(10);
auto_mode_check();
delay_ms(10);
timer_event_check();
delay_ms(10);
}
```

## 4.26任务
### （1）
#### ①配置RTC实时时钟
#### ②每次上电更新系统时间
- 方案1：AT指令
- 方案2：阿里云下放时间，解析时间
#### ③根据系统时间执行定时任务、闹钟
### （2）循环检测情景模式
### （3）循环检测自动化模式的数据
### （4）
#### 安卓获取设备状态：
- 安卓发送设备状态请求报文:{smart_set:${user}} 响应时间3秒 
- stm32响应 发送ack
### (5) 安卓上线：
  #### ①有用户登录，获取设备状态在线、服务器在线：正常使用
  #### ②无用户登录、服务器在线，设备在线：仅可查看传感器数据，界面提示访客模式
  #### ③服务器离线，设备在线：仅可查看传感器数据，界面提示服务器异常
  #### ④无用户登录、服务器在线，设备离线：什么都做不了：提示设备离线
  #### ⑤有用户登录、服务器在线，设备离线：仅能查看历史数据，其他操作提示设备离线
  +++
  #### 仅服务器在线且设备在线才：用户登录\退出登录时，发消息给stm32
  #### ①仅当服务器在线且用户登录、设备在线才可操作设备
  #### ②若设备离线：服务器在线且用户登录：仅能查看历史数据
### (6)STM32上线
      发送ack
### (7) 初始化逻辑修改
- 初始化esp8266->初始化阿里云，某一步骤出错，直接跳出，给出出错信息。仅当不出错时才进行联网操作
- esp8266初始化出错，仅提示，不做处理；阿里云初始化出错，每隔30s重连，使用全局变量,u8 isNeedReconnect;
### (8)发送数据逻辑修改
数据下发时，3s内才可再次下发 isEnable = sendingDataViewModel.value;

## 4.29任务
### 1、安卓增加检查服务器和设备在线状况按钮
- 设备在线状况:{smart_set:shakehand} {ack:ok}
- 服务器在线状况 
### 2、修改曲线图数据量
### 3、增加数据同步按钮
#### 设备同步到安卓
- 发送同步请求(检查设备在线状况)开始转圈圈，等待响应：响应成功，开始同步，失败，给出提示
- 响应完成 {smart_set:sync_start}设备打包数据:
```
{"stm32_sync":{"bedroomLED":},{"toliteLED":%d},{"livingroomParam":{"state":%d},{"r":%d},{"g":%d},{"b":%d}},{"fan_param":{"state":%d},{"speed":%d},{"direction":%d}},{"curtain":%d},{"alarmSwitch":%d}}
```
发完后{"ack":"sync_ok"}       click->    var checkOK = deviceCheck() ->变量syncStartFlag = true->转圈圈 收到sync_ok->syncStartFlag = false;停止转圈圈
 安卓同步到设备:发送同步请求，等待设备响应，开始转圈圈，逐个同步，逐个确认。改造发送数据方法，使其含返回值
      ack=false   sendRes,syncNum.res = send1   if(res)syncNum++  res = send2 if(res)syncNum++ ...............if(syncNum==6){msg:同步成功}else{msg{同步失败,已同步syncNum/6}}
        
④增加报警通报功能：stm32 ppm浓度过高,发送{"stm32_set":"warning"}    安卓显示报警弹窗

```
@Composable
fun WarningDialog(onDismiss: () -> Unit) {
    var showDialog by remember { mutableStateOf(true) }

    if (showDialog) {
        AlertDialog(
            onDismissRequest = {
                onDismiss()
                showDialog = false
            },
            title = {
                Text(
                    text = "警告",
                    fontSize = 20.sp,
                    color = Color.Red
                )
            },
            text = {
                Text(
                    text = "室内污染严重，为了您的健康，请及时处理！",
                    fontSize = 16.sp
                )
            },
            buttons = {
                Row(
                    modifier = Modifier
                        .padding(8.dp)
                        .fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    Button(
                        onClick = {
                            onDismiss()
                            showDialog = false
                        },
                        modifier = Modifier.padding(end = 8.dp)
                    ) {
                        Text(text = "确定")
                    }
                }
            },
            backgroundColor = Color.White,
            contentColor = Color.Black,
            shape = RoundedCornerShape(8.dp)
        )
    }
}
```
    ⑤发送通知:
```
private fun createNotificationChannel(context: Context, channelId: String) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        val channel = NotificationChannel(
            channelId,
            "Channel Name",
            NotificationManager.IMPORTANCE_DEFAULT
        ).apply {
            description = "Channel Description"
        }
        val notificationManager: NotificationManager =
            context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        notificationManager.createNotificationChannel(channel)
    }
}
private fun sendNotification(
    context: Context,
    title: String,
    content: String
) {
    val notificationId = 123
    val channelId = "channel_id" // 创建通知渠道时使用的ID
    val notificationManager = NotificationManagerCompat.from(context)

    // 创建通知渠道
    createNotificationChannel(context, channelId)

    // 构建通知
    val notification = NotificationCompat.Builder(context, channelId)
        .setContentTitle(title)
        .setContentText(content)
        .setSmallIcon(R.drawable.ic_notification_icon)
        .setPriority(NotificationCompat.PRIORITY_DEFAULT)

    // 发送通知
    notificationManager.notify(notificationId, notification.build())
}

<uses-permission android:name="android.permission.VIBRATE" />
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
<application
    ...
    <receiver android:name=".MyBroadcastReceiver" android:enabled="true" android:exported="false">
        <intent-filter>
            <action android:name="android.intent.action.BOOT_COMPLETED"/>
        </intent-filter>
    </receiver>
</application>

```
