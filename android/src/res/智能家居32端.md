
### 主函数
```
int main(){

初始化:{
  ①各个传感器初始化
  ②指纹模块等硬件初始化
  ③esp8266初始化
  ④阿里云初始化
  }
  身份验证
  验证成功：发送ack提示设备上线
while(1){
response();
update_environment_data();
alarm_clock_check();
auto_mode_check();


}
}


while(1){

update_environment_data();
delay_ms(10);
response(1);
delay_ms(10);
alarm_clock_check();
delay_ms(10);
auto_mode_check();
delay_ms(10);
timer_event_check();
delay_ms(10);
}
```

## 4.26任务
### （1）
#### ①配置RTC实时时钟
#### ②每次上电更新系统时间
- 方案1：AT指令
- 方案2：阿里云下放时间，解析时间
#### ③根据系统时间执行定时任务、闹钟
### （2）循环检测情景模式
### （3）循环检测自动化模式的数据
### （4）
#### 安卓获取设备状态：
- 安卓发送设备状态请求报文:{smart_set:${user}} 响应时间3秒 
- stm32响应 发送ack
### (5) 安卓上线：
  #### ①有用户登录，获取设备状态在线、服务器在线：正常使用
  #### ②无用户登录、服务器在线，设备在线：仅可查看传感器数据，界面提示访客模式
  #### ③服务器离线，设备在线：仅可查看传感器数据，界面提示服务器异常
  #### ④无用户登录、服务器在线，设备离线：什么都做不了：提示设备离线
  #### ⑤有用户登录、服务器在线，设备离线：仅能查看历史数据，其他操作提示设备离线
  +++
  #### 仅服务器在线且设备在线才：用户登录\退出登录时，发消息给stm32
  #### ①仅当服务器在线且用户登录、设备在线才可操作设备
  #### ②若设备离线：服务器在线且用户登录：仅能查看历史数据
### (6)STM32上线
      发送ack
### (7) 初始化逻辑修改
- 初始化esp8266->初始化阿里云，某一步骤出错，直接跳出，给出出错信息。仅当不出错时才进行联网操作
- esp8266初始化出错，仅提示，不做处理；阿里云初始化出错，每隔30s重连，使用全局变量,u8 isNeedReconnect;
### (8)发送数据逻辑修改
数据下发时，3s内才可再次下发 isEnable = sendingDataViewModel.value;

## 4.29任务
### 1、安卓增加检查服务器和设备在线状况按钮
- 设备在线状况:{smart_set:shakehand} {ack:ok}
- 服务器在线状况 
### 2、修改曲线图数据量
### 3、增加数据同步按钮
#### 设备同步到安卓
- 发送同步请求(检查设备在线状况)开始转圈圈，等待响应：响应成功，开始同步，失败，给出提示
- 响应完成 {smart_set:sync_start}设备打包数据:
```
{"stm32_sync":{"bedroomLED":},{"toliteLED":%d},{"livingroomParam":{"state":%d},{"r":%d},{"g":%d},{"b":%d}},{"fan_param":{"state":%d},{"speed":%d},{"direction":%d}},{"curtain":%d},{"alarmSwitch":%d}}
```
- 发完后{"ack":"sync_ok"}       click->    var checkOK = deviceCheck() ->变量syncStartFlag = true->转圈圈 收到sync_ok->syncStartFlag = false;停止转圈圈
- 安卓同步到设备:发送同步请求，等待设备响应，开始转圈圈，逐个同步，逐个确认。改造发送数据方法，使其含返回值
```
      ack=false   sendRes,syncNum.res = send1   if(res)syncNum++  res = send2 if(res)syncNum++ ...............if(syncNum==6){msg:同步成功}else{msg{同步失败,已同步syncNum/6}}
```         
### 4、增加报警通报功能
stm32 ppm浓度过高,发送{"stm32_set":"warning"}    安卓显示报警弹窗

```
@Composable
fun WarningDialog(onDismiss: () -> Unit) {
    var showDialog by remember { mutableStateOf(true) }

    if (showDialog) {
        AlertDialog(
            onDismissRequest = {
                onDismiss()
                showDialog = false
            },
            title = {
                Text(
                    text = "警告",
                    fontSize = 20.sp,
                    color = Color.Red
                )
            },
            text = {
                Text(
                    text = "室内污染严重，为了您的健康，请及时处理！",
                    fontSize = 16.sp
                )
            },
            buttons = {
                Row(
                    modifier = Modifier
                        .padding(8.dp)
                        .fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    Button(
                        onClick = {
                            onDismiss()
                            showDialog = false
                        },
                        modifier = Modifier.padding(end = 8.dp)
                    ) {
                        Text(text = "确定")
                    }
                }
            },
            backgroundColor = Color.White,
            contentColor = Color.Black,
            shape = RoundedCornerShape(8.dp)
        )
    }
}
```
    ⑤发送通知:
```
private fun createNotificationChannel(context: Context, channelId: String) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
        val channel = NotificationChannel(
            channelId,
            "Channel Name",
            NotificationManager.IMPORTANCE_DEFAULT
        ).apply {
            description = "Channel Description"
        }
        val notificationManager: NotificationManager =
            context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        notificationManager.createNotificationChannel(channel)
    }
}
private fun sendNotification(
    context: Context,
    title: String,
    content: String
) {
    val notificationId = 123
    val channelId = "channel_id" // 创建通知渠道时使用的ID
    val notificationManager = NotificationManagerCompat.from(context)

    // 创建通知渠道
    createNotificationChannel(context, channelId)

    // 构建通知
    val notification = NotificationCompat.Builder(context, channelId)
        .setContentTitle(title)
        .setContentText(content)
        .setSmallIcon(R.drawable.ic_notification_icon)
        .setPriority(NotificationCompat.PRIORITY_DEFAULT)

    // 发送通知
    notificationManager.notify(notificationId, notification.build())
}

<uses-permission android:name="android.permission.VIBRATE" />
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
<application
    ...
    <receiver android:name=".MyBroadcastReceiver" android:enabled="true" android:exported="false">
        <intent-filter>
            <action android:name="android.intent.action.BOOT_COMPLETED"/>
        </intent-filter>
    </receiver>
</application>

```
